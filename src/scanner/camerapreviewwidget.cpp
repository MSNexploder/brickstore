// Copyright (C) 2004-2024 Robert Griebl
// SPDX-License-Identifier: GPL-3.0-only

#include <QtCore/QCoreApplication>
#include <QtWidgets/QVBoxLayout>
#include <QtGui/QHelpEvent>
#include <QtQuick/QQuickView>
#include <QtQuick/QQuickItem>
#include <QQmlEngine>

#include "camerapreviewwidget.h"
#ifdef BS_USE_TYPE_COMPILER
#ifdef Q_CC_MSVC
#  pragma warning(push)
#  pragma warning(disable: 4458) // in qquickitem_p.h
#endif
#include "camerapreview.h" // generated by qmltc
#ifdef Q_CC_MSVC
#  pragma warning(pop)
#endif

#if QT_VERSION < QT_VERSION_CHECK(6, 6, 0)
namespace Scanner {
class CameraPreview : public ::CameraPreview {
public:
    CameraPreview(QQmlEngine *e)
        : ::CameraPreview(e)
    { }
};
}
#endif
#else
namespace Scanner {

// This is a very hacky way to NOT use qmltc (Debian bug 1060228), but also avoid
// a ton of #ifdefs in the actual application logic below

class CameraPreview : public QObject
{
    Q_OBJECT
public:
    CameraPreview(QQmlEngine *e)
    {
        QQmlComponent c(e);
        c.loadUrl(u"qrc:/Scanner/CameraPreview.qml"_qs);
        auto obj = c.create();
        m_root = qobject_cast<QQuickItem *>(obj);
        if (m_root)
            connect(m_root, SIGNAL(clicked()), this, SIGNAL(clicked()));
    }
    void setParentItem(QQuickItem *parent)
    {
        if (m_root) m_root->setParentItem(parent);
    }
    bool active() const
    {
        return m_root ? m_root->property("active").toBool() : false;
    }
    void setActive(bool a)
    {
        if (m_root) m_root->setProperty("active", a);
    }
    QObject *videoOutput() const
    {
        return m_root;
    }
    Q_SIGNAL void clicked();

private:
    QQuickItem *m_root = nullptr;
};

}
#endif

CameraPreviewWidget::CameraPreviewWidget(QQmlEngine *engine, QWidget *parent)
    : QWidget(parent)
{
    setFocusPolicy(Qt::NoFocus);

    auto layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);

    auto window = engine ? new QQuickView(engine, nullptr) : new QQuickView();
    window->setResizeMode(QQuickView::SizeRootObjectToView);
    window->setColor(Qt::black);

    m_cameraPreview = new Scanner::CameraPreview(engine);
    m_cameraPreview->setParentItem(window->contentItem());
    auto widget = QWidget::createWindowContainer(window, this);

    connect(m_cameraPreview, &Scanner::CameraPreview::clicked,
            this, &CameraPreviewWidget::clicked);

    int videoWidth = logicalDpiX() * 3; // ~7.5cm on-screen
    widget->setMinimumSize(videoWidth, videoWidth * 9 / 16);
    widget->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    layout->addWidget(widget, 10);
}

CameraPreviewWidget::~CameraPreviewWidget()
{
    m_cameraPreview->setParentItem(nullptr);
    delete m_cameraPreview;
}

bool CameraPreviewWidget::isActive() const
{
    return m_cameraPreview->active();
}

void CameraPreviewWidget::setActive(bool newActive)
{
    m_cameraPreview->setActive(newActive);
}

QObject *CameraPreviewWidget::videoOutput() const
{
#ifdef BS_USE_TYPE_COMPILER
    return m_cameraPreview;
#else
    return m_cameraPreview->videoOutput();
#endif
}

#include "camerapreviewwidget.moc"
